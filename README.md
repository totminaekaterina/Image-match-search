# Image match search using K Nearest Neighbors and Correspondence to other classes

## Постановка задачи

Цель задачи заключается в разработке алгоритма, который позволяет сравнивать изображения с использованием двух методов: ближайших соседей (Nearest Neighbors) и соответствия другим классам (Correspondence to other classes). Алгоритм должен предоставить возможность находить наиболее похожие изображения из базового набора данных для заданного тестового изображения. Метод Nearest Neighbors позволяет находить наиболее близкие по признакам изображения в базе данных, а метод Correspondence позволяет определять, насколько хорошо тестовое изображение соответствует изображениям из других классов. Разработанный алгоритм должен быть способен вычислять точность сопоставлений и визуализировать результаты для оценки качества работы алгоритма.

На вход алгоритму подается изображение, для которого требуется найти наиболее близкие по содержанию изображения в базе данных.  В результате работы алгоритма получаем топ-5 или топ-10 наиболее подходящих изображений из базы данных, отсортированных по степени их соответствия входному изображению. Это позволяет пользователям быстро найти схожие по содержанию изображения и использовать их в соответствии с их потребностями.

## Этапы выполнения задачи

1. Предобработка предоставленных данных — приведение их к единому формату.
2. Загрузка предобученной модели компьютерного зрения ResNet с 50-ю слоями.
3. Удаление последних слоев классификации с целью оставить только слои, необходимые для извлечения признаков.
4. Преобразование изображений из тестового и базового наборов в тензоры путем подачи их через модель ResNet и получение векторов признаков.
5. Применение одного из двух алгоритмов для поиска наиболее похожих изображений из базового набора:
    - Nearest Neighbors.
    - Correspondence to other classes.
6. Возвращение меток классов изображений в виде топ-5 мэтчей.

### Этап 1. Предобработка данных из базового и тестового датасетов

The base dataset was created for the purposes of the study, comprising 225 images divided into 5 classes (subfolders in the main folder). These classes were defined as follows: "Kitchen", "Living room", "Bathroom", "Bedroom" and "Wardrobe". A similar structure was used to create the test dataset, containing a total of 25 images, with 5 images for each class.

Images from the test dataset were used for comparison with images from the base dataset.

создаются необходимые директории для предварительной обработки изображений, включая папки для классов изображений. Затем определяются функции для создания директорий и предварительной обработки изображений, включая их сохранение в соответствующих папках. После этого происходит загрузка и обработка изображений из базового и тестового наборов данных, с последующим сохранением их в папках предобработанных базовых и тестовых изображений. В результате этого процесса изображения подвергаются уменьшению размеров (1028 на 768 пикселей) (Fig.1) и организации в соответствующих папках, готовых для использования в алгоритме сопоставления изображений.

![photo_example](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/photo_example.png)

### Этап 2. Загрузка предобученной модели ResNet50

ResNet-50 - это глубокая сверточная нейронная сеть, предварительно обученная на большом наборе данных изображений ImageNet. Она состоит из 50 слоев и имеет доказанную способность к высокой точности классификации изображений.

Модель ResNet-50 была выбрана из-за ряда преимуществ, которые она предоставляет:

Глубокая архитектура: ResNet-50 состоит из 50 слоев, что делает ее достаточно глубокой для извлечения высокоуровневых признаков из изображений. Это позволяет модели улавливать более сложные шаблоны и особенности изображений.

### Этап 3. Удаление последних слоев классификации в моделе

В данном случае модель ResNet-50 используется не для классификации изображений, а для извлечения признаков из них. Это осуществляется путем удаления последних слоев классификации и использования оставшихся слоев для получения представлений (признаков) изображений с помощью `model = torch.nn.Sequential(*(list(model.children())[:-1]))`, где:

1. `model.children()` возвращает генератор, содержащий все дочерние слои модели.
2. `list(model.children())` преобразует генератор в список, чтобы можно было использовать индексацию и срезы.
3. `[:-1]` выполняет срез списка, оставляя все элементы до последнего (исключая последний элемент).
4. `torch.nn.Sequential(*...)` создает новую последовательность слоев PyTorch, которая будет содержать все слои модели, за исключением последнего.

Такой подход часто используется в случае, когда последний слой модели отвечает за классификацию, а мы хотим использовать модель именно для извлечения признаков.


### Этап 4. Преобразование изображений из тестового и базового наборов в тензоры и получение векторов признаков

Ранее обработанные изображения снова преобразуются в тензоры и подаются в модель ResNet, чтобы она выделила из них признаки, с помощью которых далее будут сравниваться картинься между собой (See below).

`# Feature extraction
def extract_features(image_tensor):
    with torch.no_grad():
        features = model(image_tensor)
    features = features.squeeze().numpy()
    return features`

1. `image_tensor` - это тензор изображения, который передается в качестве входных данных для модели.
2. `with torch.no_grad():` - контекстный менеджер отключает требование градиентов во время вычислений. Это полезно в данном случае, так как мы не обучаем модель, а только используем ее для извлечения признаков.
3. `features = model(image_tensor)`: Подача тензора изображения в модель, которая его обрабатывает и возвращает его признаки.
4. `features.squeeze().numpy()` - полученные признаки сжимаются (если они имеют размерность 1) и преобразуются в массив NumPy, чтобы получить одномерный массив признаков, и возвращает этот массив.

### Этап 5. Применение алгоритмов для поиска наиболее похожих изображений из базового набора

#### Использование алгоритма Nearest Neighbors

На вход принимаются признаки запроса (`query_features`), признаки базы данных (`database_features`), метки базы данных (`database_labels`) и опциональный параметр `k`, который указывает количество соседей, которые нужно найти (в нашем случае - 5).
    - Создает объект `NearestNeighbors` с использованием метрики `cosine` (косинусное расстояние).
    - Обучает модель на признаках базы данных с помощью метода `fit`.
    - Использует метод `kneighbors` для нахождения `k` ближайших соседей для признаков запроса.
    - Возвращает расстояния (`distances`) и индексы (`indices`) этих ближайших соседей.

Также было решено использовать Accuracy, чтобы устаноовить правильно ли модель опрделяет класс базового изображения, с которым сравнивается тестовое, и которое наиболее близкое к нему. Далее метрика выводится для каждого тестового изображения и топ 5 самых близких к нему по косиносному растоянию базовых изображений. Примеры полученных результатов для класса "Kitchen" (Fig.2) и класса "Bathroom" (Fig.3)

![kithen_example](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/kitchen_example.png)

![kithen_rank](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/kitchen_example.png)

![bathroom_example](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/bathroom_example.png)

![bathroom_rank](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/bathroom_rank.png)

**Как результат** в первом подходе оценивалась близость изображения к изображениям в базе данных того же класса, а затем сравнивалась точность этого сопоставления, так что показатель тотальных показатель точности всегда будет 100%. При визуальной оценке, можно сказать, что модель правильно определила топ 5 самых "близких" изображений.


#### Использование алгоритма Nearest Neighbors

Использование метода `Correspondence to other classes` подразумевает, что каждое изображение из тестового набора может соответствовать изображениям из базы данных других классов, а не только своему собственному классу. Ниже представлена логика использования второго подхода:

1. Для каждого изображения из тестового набора вычисляются сходства между его признаками и признаками изображений в базе данных с помощью косинусной близости (так же как и 
 в первом подходе). Косинусное сходство - это мера сходства между двумя векторами в многомерном пространстве, что прекрасно подходит нам для решения поставленной задачи.
2. Далее вычисляется точность соответствия изображений с другими классами. Для этого считается количество правильных совпадений изображений с классами, отличными от тестового класса, и делится на общее количество изображений, для которых выполняется сопоставление (параметр `k`). 
3. Как результат, возвращается массив индексов изображений из базы данных с наибольшими сходствами и вычисленную точность соответствия, а также те самые наиболее близкие изображения.

Ниже представлены результаты, полученные для тестового изображения из класса "Bedroom" (Fig.4) и "Wardrobe" (Fig.5). Тотальная точность алгоритма составляет 94%, что является довольно высоким результатом.

![bedroom_example](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/bedroom_example.png)

![bedroom_rank](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/bedroom_rank.png)

![wardrobe_example](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/wardrobe_example.png)

![wardrobe_rank](https://github.com/totminaekaterina/Image-match-search/blob/main/imgs/wardrobe_rank.png)

**Как результат**, второй подход позволяет оценить, насколько изображение соответствует классам, отличным от его собственного, и измерить точность этого соответствия. В нем используется метод сопоставления на основе сходства косинусов, в то время как предыдущий подход использовал метод ближайших соседей с косинусным расстоянием.


**Вывод**
Оба подхода могут использоваться для оценки производительности модели сопоставления изображений, несмотря на то, что они фокусируются на различных аспектах сходства и различиях между изображениями.

